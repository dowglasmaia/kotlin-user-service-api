# User Service (Kotlin + Spring Boot) — Create User Flow

A **production-ready “Create User” flow** built with **Kotlin**, **Spring Boot**, and **Spring Data JPA**.
It follows **Hexagonal Architecture (Ports & Adapters)** and **SOLID** principles to ensure scalability, maintainability, and clear separation of concerns.

* **Domain safety by design:** `Email` and `Cpf` as Kotlin **value objects** (`@JvmInline`) with invariant checks.
* **Framework-agnostic core:** Use cases depend on **ports**, not on JPA or Spring.
* **Operational quality:** centralized error handling, UUID IDs, ISO-8601 timestamps.

---

## Overview

**Goal:** expose `POST /users` to create a user with `name`, `email`, `cpf`, and `profession`, enforcing validation and uniqueness (email/CPF), persisting to PostgreSQL.

**Highlights**

* Kotlin `data class` for DTOs; value objects for domain invariants (Email, Cpf)
* Application use case decoupled from persistence via ports
* JPA adapter as an infrastructure detail
* Centralized error handling with `@RestControllerAdvice`
* UUID identifiers (generated by Hibernate) and ISO-8601 timestamps

---

## Tech Stack

* **Language:** Kotlin (JVM 21)
* **Framework:** Spring Boot 3 
* **Persistence:** Spring Data JPA (Hibernate) + PostgreSQL
* **Validation:** Bean Validation (Jakarta Validation + Hibernate Validator)
* **Build:** Maven

---

## Architecture

**Clean Architecture / Ports & Adapters (Hexagonal)**

```
            +-------------------+
            |     API Layer     |  → Controller + DTOs
            +---------+---------+
                      |
                      v
            +-------------------+
            |  Application Core |  → Use Cases (CreateUserUseCase)
            |   (Use Cases)     |     Ports: IN (commands) / OUT (UserRepository)
            +---------+---------+
                      |
                      v
            +-------------------+
            |     Domain        |  → Entities (User), Value Objects (Email, Cpf)
            +---------+---------+
                      |
                      v
            +-------------------+
            |  Infrastructure   |  → JPA Adapter + Spring Data Repository
            +-------------------+
```

* **API (web)** talks **only** to the **application** (use case).
* **Use case** depends on **ports** (interfaces), not on JPA.
* **Infrastructure** implements **adapters** to satisfy the ports.

---

## Module & Package Structure (suggestion)

```
com.dowglasmaia.demouserserviceapi
 ├─ api
 │   ├─ UserController.kt
 │   ├─ UserApiModels.kt               # CreateUserRequest, UserResponse
 │   └─ ApiExceptionHandler.kt         # @RestControllerAdvice
 ├─ application
 │   ├─ port
 │   │   ├─ in/CreateUserUseCase.kt    # command + output DTO
 │   │   └─ out/UserRepository.kt
 │   └─ service/CreateUserService.kt   # business rules
 ├─ domain
 │   ├─ model/User.kt                  # entity (domain)
 │   ├─ model/Email.kt                 # value object
 │   ├─ model/Cpf.kt                   # value object
 │   └─ exception/*.kt                 # EmailAlreadyUsedException, etc.
 └─ infrastructure
     └─ persistence
         └─ jpa
             ├─ UserEntity.kt
             ├─ SpringUserJpaRepository.kt
             └─ UserJpaAdapter.kt
```

---
## Why this is **SOLID**

* **SRP (Single Responsibility Principle)**
  Each class has a single reason to change:

  * DTOs (transport shape), Controller (HTTP concerns),
  * Use Case (business rule),
  * Port (contract),
  * Adapter (JPA details),
  * Domain (invariants via value objects).

* **DIP (Dependency Inversion Principle)**
  The use case depends on the **`UserRepository` interface**, not on JPA. Infrastructure depends on the domain/application, never the other way.

* **OCP (Open/Closed Principle)**
  You can add a new persistence adapter (e.g., Redis, DynamoDB) **without** modifying the use case: implement the `UserRepository` port and wire it.

* **ISP (Interface Segregation Principle)**
  `UserRepository` exposes only what the use case needs (no leaking of JPA-specific APIs).

* **LSP (Liskov Substitution Principle)**
  Any adapter that implements `UserRepository` can replace another without breaking the service (same contract, same semantics).

---

## API Contract

**Endpoint**

```
POST /users
Content-Type: application/json
```

**Request**

```json
{
  "name": "Ana Silva",
  "email": "ana.silva@example.com",
  "cpf": "39053344705",
  "profession": "Software Engineer"
}
```

**Response (201 Created)**

```json
{
  "id": "3c6b8f5a-3f1d-4a18-bb3c-c3ea2b0f6b9a",
  "name": "Ana Silva",
  "email": "ana.silva@example.com",
  "cpf": "39053344705",
  "profession": "Software Engineer",
  "createdAt": "2025-08-23T18:27:11Z"
}
```

**Error Responses**

* `400 Bad Request` — validation error / malformed JSON
* `409 Conflict` — email or CPF already in use (or DB unique constraint)
* `404 Not Found` — if later you add reads and the resource doesn’t exist
* `500 Internal Server Error` — unexpected error (central handler)

---

## DTOs (API Layer)

* `CreateUserRequest` — Bean Validation annotations (`@Email`, `@CPF`, `@NotBlank`, `@Size`) with `@field:` usage in Kotlin.
* `UserResponse` — public shape returned to clients.

> Use Kotlin `data class` for immutability and concise models (record-like).

---

## Domain

* `User` — domain entity with business-friendly fields (`Email`, `Cpf`) and an explicit factory (`User.create(...)`) to apply invariants early.
* `Email` & `Cpf` — **value objects** encapsulating validation and normalization (lowercase email, CPF digits-only). This localizes rules and keeps the domain clean.

---

## Application (Use Case)

* `CreateUserUseCase` + `CreateUserService`

    * Normalize inputs (trim, lowercase email, digits-only CPF)
    * Enforce **uniqueness** via port `UserRepository`
    * Persist and map back to output DTO (`CreatedUserDto`)
    * Return ISO-8601 timestamp

> The use case **does not** know JPA. It depends only on the **out port**.

---

## Ports (DIP)

* **IN port:** `CreateUserUseCase` (controller calls this)
* **OUT port:** `UserRepository` (application calls this to persist)

```kotlin
interface UserRepository {
  fun existsByEmail(email: String): Boolean
  fun existsByCpf(cpf: String): Boolean
  fun save(user: User): User
  fun findById(id: UUID): User?
}
```

---

## Infrastructure (JPA Adapter)

* `UserEntity` — JPA entity (class, not data class), `@GeneratedValue(strategy = GenerationType.UUID)` with **nullable** `id: UUID? = null`
* `SpringUserJpaRepository` — Spring Data interface with derived queries:

    * `existsByEmailIgnoreCase(email: String): Boolean`
    * `existsByCpf(cpf: String): Boolean`
* `UserJpaAdapter` — maps domain ⇄ entity and implements `UserRepository`

> **ID strategy:** Prefer letting Hibernate **generate UUID**. In the adapter, set `id = null` on insert and read the generated UUID back when mapping to domain.

---

## Validation

* Bean Validation on `CreateUserRequest` (`@Email`, `@CPF`, `@NotBlank`, `@Size`)
* Domain **value objects** also validate (defense in depth)
* Normalize before persist (email lowercase, CPF digits-only)

---

## Error Handling

`@RestControllerAdvice` centralizes errors:

```kotlin
// 400 — Bad Request: malformed JSON or invalid value type
// 400 — Bad Request: missing required query/form parameter
// 400 — Bad Request: validation error in request body
// 409 — Conflict (business): email/CPF already in use
// 409 — Conflict (DB guard): unique constraint violation that slipped past the service layer
// 404 — Not Found: thrown when a resource is not found
// 500 — Internal Server Error: unexpected error (logged)
```

Returns a consistent `ErrorResponse` with `timestamp`, `path`, `status`, `error`, `message`, and optional field errors.

---
### Create Table
```sql
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY,
  name VARCHAR(120) NOT NULL,
  email VARCHAR(255) NOT NULL,
  cpf VARCHAR(11) NOT NULL,
  profession VARCHAR(120) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS ux_users_email ON users (LOWER(email));
CREATE UNIQUE INDEX IF NOT EXISTS ux_users_cpf   ON users (cpf);
```

---

## Clean Architecture Benefits Applied

* **Independent of frameworks:** Spring is an outer detail; business rules live in the application/domain.
* **Testable:** Use case can be tested with a mock repository (no DB).
* **Replaceable infrastructure:** Swap JPA for another store by changing only the adapter.
* **Explicit boundaries:** Controller ↔ Use Case ↔ Port ↔ Adapter separation keeps coupling low.
